package main

import (
	"reflect"

	"github.com/Eun/go-hit/generators/helpers"

	"fmt"
	"strings"

	"regexp"

	"github.com/dave/jennifer/jen"
)

var matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
var matchAllCap = regexp.MustCompile("([a-z0-9])([A-Z])")

func toSnakeCase(str string) string {
	snake := matchFirstCap.ReplaceAllString(str, "${1}_${2}")
	snake = matchAllCap.ReplaceAllString(snake, "${1}_${2}")
	return strings.ToLower(snake)
}

func genFunc(typeName, name string, params []jen.Code, clearPathParam, execBlock jen.Code) jen.Code {
	return jen.Func().Params(jen.Id("v").Op("*").Id(typeName)).Id(name).Params(params...).Id("IStep").Block(
		jen.Return(jen.Op("&").Id("hitStep").Values(
			jen.Id("Trace").Op(":").Id("ett").Dot("Prepare").Call(),
			jen.Id("When").Op(":").Id("ExpectStep"),
			jen.Id("CallPath").Op(":").Id("v").Dot("cp").Dot("Push").Call(jen.Lit(name), clearPathParam),
			jen.Id("Exec").Op(":").Func().Params(jen.Id("hit").Op("*").Id("hitImpl")).Error().Block(execBlock),
		)),
	)
}

func generateForType(t interface{}, representation string) error {
	v := reflect.ValueOf(t)

	f := jen.NewFile("hit")
	f.HeaderComment("+build !generate_numeric")
	f.Comment("⚠️⚠️⚠️ This file was autogenerated by generators/expect/numeric ⚠️⚠️⚠️ //")

	f.Line()

	name := fmt.Sprintf("expect%s", strings.Title(v.Type().Name()))
	interfaceName := "I" + strings.Title(name)

	f.Commentf("%s provides assertions for the %s type.", interfaceName, v.Type().Name())

	f.Type().Id(interfaceName).Interface(
		jen.Commentf("Equal expects the %[1]s to be equal to the specified value.", v.Type().Name()),
		jen.Id("Equal").Params(jen.Id("value").Id(v.Type().Name())).Id("IStep"),
		jen.Line(),

		jen.Commentf("NotEqual expects the %[1]s to be not equal to the specified value.", v.Type().Name()),
		jen.Id("NotEqual").Params(jen.Id("value").Op("...").Id(v.Type().Name())).Id("IStep"),
		jen.Line(),

		jen.Commentf("OneOf expects the %[1]s to be equal to one of the specified values.", v.Type().Name()),
		jen.Id("OneOf").Params(jen.Id("values").Op("...").Id(v.Type().Name())).Id("IStep"),
		jen.Line(),

		jen.Commentf("NotOneOf expects the %[1]s to be not equal to one of the specified values.", v.Type().Name()),
		jen.Id("NotOneOf").Params(jen.Id("values").Op("...").Id(v.Type().Name())).Id("IStep"),
		jen.Line(),

		jen.Commentf("GreaterThan expects the %[1]s to be not greater than the specified value.", v.Type().Name()),
		jen.Id("GreaterThan").Params(jen.Id("value").Id(v.Type().Name())).Id("IStep"),
		jen.Line(),

		jen.Commentf("LessThan expects the %[1]s to be less than the specified value.", v.Type().Name()),
		jen.Id("LessThan").Params(jen.Id("value").Id(v.Type().Name())).Id("IStep"),
		jen.Line(),

		jen.Commentf("GreaterOrEqualThan expects the %[1]s to be greater or equal than the specified value.", v.Type().Name()),
		jen.Id("GreaterOrEqualThan").Params(jen.Id("value").Id(v.Type().Name())).Id("IStep"),
		jen.Line(),

		jen.Commentf("LessOrEqualThan expects the %[1]s to be less or equal than the specified value.", v.Type().Name()),
		jen.Id("LessOrEqualThan").Params(jen.Id("value").Id(v.Type().Name())).Id("IStep"),
		jen.Line(),

		jen.Commentf("Between expects the %[1]s to be between the specified min and max value (inclusive, min >= %[1]s >= max).", v.Type().Name()),
		jen.Id("Between").Params(jen.Id("min"), jen.Id("max").Id(v.Type().Name())).Id("IStep"),
		jen.Line(),

		jen.Commentf("NotBetween expects the %[1]s to be not between the specified min and max value (inclusive, min >= %[1]s >= max).", v.Type().Name()),
		jen.Id("NotBetween").Params(jen.Id("min"), jen.Id("max").Id(v.Type().Name())).Id("IStep"),
	)

	// generate callback type
	callbackType := fmt.Sprintf("expect%sValueCallback", strings.Title(v.Type().Name()))

	f.Type().Id(callbackType).Func().Params(jen.Id("hit").Id("Hit")).Op(v.Type().Name())

	// create struct
	f.Type().Id(name).Struct(
		jen.Id("cp").Id("callPath"),
		jen.Id("valueCallback").Id(callbackType),
	)

	// generate constructor
	f.Func().
		Id(fmt.Sprintf("new%s", strings.Title(name))).
		Params(jen.Id("cp").Id("callPath"), jen.Id("valueCallback").Id(callbackType)).
		Id(interfaceName).Block(
		jen.Return(jen.Op("&").Id(name).Values(
			jen.Id("cp").Op(":").Id("cp"),
			jen.Id("valueCallback").Op(":").Id("valueCallback"),
		)),
	)

	// generate methods

	// exec func
	f.Add(genFunc(name, "Equal", []jen.Code{jen.Id("value").Id(v.Type().Name())}, jen.Op("[]interface{}").Values(jen.Id("value")), jen.Return(
		jen.Qual("github.com/Eun/go-hit/internal/minitest", "Equal").Call(jen.Id("v").Dot("valueCallback").Call(jen.Id("hit")), jen.Id("value")),
	)))

	f.Add(genFunc(name, "NotEqual", []jen.Code{jen.Id("values").Op("...").Id(v.Type().Name())}, jen.Op(fmt.Sprintf("%sSliceToInterfaceSlice", v.Type().Name())).Call(jen.Id("values")), jen.Return(
		jen.Qual("github.com/Eun/go-hit/internal/minitest", "NotEqual").Call(jen.Id("v").Dot("valueCallback").Call(jen.Id("hit")), jen.Op(fmt.Sprintf("%sSliceToInterfaceSlice", v.Type().Name())).Call(jen.Id("values")).Op("...")),
	)))

	f.Add(genFunc(name, "OneOf", []jen.Code{jen.Id("values").Op("...").Id(v.Type().Name())}, jen.Op(fmt.Sprintf("%sSliceToInterfaceSlice", v.Type().Name())).Call(jen.Id("values")), jen.Return(
		jen.Qual("github.com/Eun/go-hit/internal/minitest", "OneOf").Call(jen.Id("v").Dot("valueCallback").Call(jen.Id("hit")), jen.Op(fmt.Sprintf("%sSliceToInterfaceSlice", v.Type().Name())).Call(jen.Id("values")).Op("...")),
	)))

	f.Add(genFunc(name, "NotOneOf", []jen.Code{jen.Id("values").Op("...").Id(v.Type().Name())}, jen.Op(fmt.Sprintf("%sSliceToInterfaceSlice", v.Type().Name())).Call(jen.Id("values")), jen.Return(
		jen.Qual("github.com/Eun/go-hit/internal/minitest", "NotOneOf").Call(jen.Id("v").Dot("valueCallback").Call(jen.Id("hit")), jen.Op(fmt.Sprintf("%sSliceToInterfaceSlice", v.Type().Name())).Call(jen.Id("values")).Op("...")),
	)))

	f.Add(genFunc(name, "GreaterThan", []jen.Code{jen.Id("value").Id(v.Type().Name())}, jen.Op("[]interface{}").Values(jen.Id("value")), jen.Add(
		jen.Id("l").Op(":=").Id("v").Dot("valueCallback").Call(jen.Id("hit")),
		jen.Line(),
		jen.If(
			jen.Id("l").Op("<=").Id("value").Block(
				jen.Return(
					jen.Qual("github.com/Eun/go-hit/internal/minitest", "Errorf").Call(jen.Lit(fmt.Sprintf("expected %[1]s to be greater than %[1]s", representation)), jen.Id("l"), jen.Id("value")),
				),
			),
		),
		jen.Line(),
		jen.Return(jen.Nil()),
	)))

	f.Add(genFunc(name, "LessThan", []jen.Code{jen.Id("value").Id(v.Type().Name())}, jen.Op("[]interface{}").Values(jen.Id("value")), jen.Add(
		jen.Id("l").Op(":=").Id("v").Dot("valueCallback").Call(jen.Id("hit")),
		jen.Line(),
		jen.If(
			jen.Id("l").Op(">=").Id("value").Block(
				jen.Return(
					jen.Qual("github.com/Eun/go-hit/internal/minitest", "Errorf").Call(jen.Lit(fmt.Sprintf("expected %[1]s to be less than %[1]s", representation)), jen.Id("l"), jen.Id("value")),
				),
			),
		),
		jen.Line(),
		jen.Return(jen.Nil()),
	)))

	f.Add(genFunc(name, "GreaterOrEqualThan", []jen.Code{jen.Id("value").Id(v.Type().Name())}, jen.Op("[]interface{}").Values(jen.Id("value")), jen.Add(
		jen.Id("l").Op(":=").Id("v").Dot("valueCallback").Call(jen.Id("hit")),
		jen.Line(),
		jen.If(
			jen.Id("l").Op("<").Id("value").Block(
				jen.Return(
					jen.Qual("github.com/Eun/go-hit/internal/minitest", "Errorf").Call(jen.Lit(fmt.Sprintf("expected %[1]s to be greater or equal than %[1]s", representation)), jen.Id("l"), jen.Id("value")),
				),
			),
		),
		jen.Line(),
		jen.Return(jen.Nil()),
	)))

	f.Add(genFunc(name, "LessOrEqualThan", []jen.Code{jen.Id("value").Id(v.Type().Name())}, jen.Op("[]interface{}").Values(jen.Id("value")), jen.Add(
		jen.Id("l").Op(":=").Id("v").Dot("valueCallback").Call(jen.Id("hit")),
		jen.Line(),
		jen.If(
			jen.Id("l").Op(">").Id("value").Block(
				jen.Return(
					jen.Qual("github.com/Eun/go-hit/internal/minitest", "Errorf").Call(jen.Lit(fmt.Sprintf("expected %[1]s to be less or equal than %[1]s", representation)), jen.Id("l"), jen.Id("value")),
				),
			),
		),
		jen.Line(),
		jen.Return(jen.Nil()),
	)))

	f.Add(genFunc(name, "Between", []jen.Code{jen.Id("min"), jen.Id("max").Id(v.Type().Name())}, jen.Op("[]interface{}").Values(jen.Id("min"), jen.Id("max")), jen.Add(
		jen.Id("l").Op(":=").Id("v").Dot("valueCallback").Call(jen.Id("hit")),
		jen.Line(),
		jen.If(
			jen.Id("l").Op("<").Id("min").Op("||").Id("l").Op(">").Id("max").Block(
				jen.Return(
					jen.Qual("github.com/Eun/go-hit/internal/minitest", "Errorf").Call(jen.Lit(fmt.Sprintf("expected %[1]s to be between %[1]s and %[1]s", representation)), jen.Id("l"), jen.Id("min"), jen.Id("max")),
				),
			),
		),
		jen.Line(),
		jen.Return(jen.Nil()),
	)))

	f.Add(genFunc(name, "NotBetween", []jen.Code{jen.Id("min"), jen.Id("max").Id(v.Type().Name())}, jen.Op("[]interface{}").Values(jen.Id("min"), jen.Id("max")), jen.Add(
		jen.Id("l").Op(":=").Id("v").Dot("valueCallback").Call(jen.Id("hit")),
		jen.Line(),
		jen.If(
			jen.Id("l").Op(">=").Id("min").Op("&&").Id("l").Op("<=").Id("max").Block(
				jen.Return(
					jen.Qual("github.com/Eun/go-hit/internal/minitest", "Errorf").Call(jen.Lit(fmt.Sprintf("expected %[1]s not to be between %[1]s and %[1]s", representation)), jen.Id("l"), jen.Id("min"), jen.Id("max")),
				),
			),
		),
		jen.Line(),
		jen.Return(jen.Nil()),
	)))

	if err := helpers.WriteJenFile(fmt.Sprintf("%s_gen.go", toSnakeCase(name)), f); err != nil {
		return err
	}
	return nil
}

func main() {
	types := []struct {
		value          interface{}
		representation string
	}{
		{int(0), "%d"},
		{int8(0), "%d"},
		{int16(0), "%d"},
		{int32(0), "%d"},
		{int64(0), "%d"},
		{uint(0), "%d"},
		{uint8(0), "%d"},
		{uint16(0), "%d"},
		{uint32(0), "%d"},
		{uint64(0), "%d"},
		{float32(0), "%f"},
		{float64(0), "%f"},
	}

	for _, g := range types {
		if err := generateForType(g.value, g.representation); err != nil {
			panic(err)
		}
	}
}
